# Handeling Missing Data

## Fetch Data

```{r}
library(httr)
library(jsonlite)
library(DBI)
library(RSQLite)

# Connect to SQLite database (create if not exists)
conn <- dbConnect(SQLite(), "anime_full_database.sqlite")

# Create a table if you don't have it yet
dbExecute(conn, "
  CREATE TABLE IF NOT EXISTS anime_full (
    mal_id INTEGER PRIMARY KEY,
    title TEXT,
    title_english TEXT,
    title_japanese TEXT,
    type TEXT,
    source TEXT,
    episodes INTEGER,
    status TEXT,
    airing BOOLEAN,
    aired_from TEXT,
    aired_to TEXT,
    duration TEXT,
    rating TEXT,
    score REAL,
    scored_by INTEGER,
    rank INTEGER,
    popularity INTEGER,
    members INTEGER,
    favorites INTEGER,
    synopsis TEXT,
    background TEXT,
    season TEXT,
    year INTEGER,
    broadcast_day TEXT,
    broadcast_time TEXT,
    broadcast_timezone TEXT,
    url TEXT
    -- You can add more columns as needed
  );
")

safe_extract <- function(x) {
  if (is.null(x) || length(x) == 0) {
    return(NA)
  } else {
    return(x)
  }
}

fetch_and_insert_anime <- function(anime_id) {
  url <- paste0("https://api.jikan.moe/v4/anime/", anime_id, "/full")
  resp <- GET(url)
  
  if (status_code(resp) == 200) {
    data <- fromJSON(content(resp, "text", encoding = "UTF-8"))$data
    
    dbExecute(conn, "
      INSERT OR REPLACE INTO anime_full 
      (mal_id, title, title_english, title_japanese, type, source, episodes, status, airing, aired_from, aired_to, duration, rating, score, scored_by, rank, popularity, members, favorites, synopsis, background, season, year, broadcast_day, broadcast_time, broadcast_timezone, url)
      VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    ", params = list(
      safe_extract(data$mal_id),
      safe_extract(data$title),
      safe_extract(data$title_english),
      safe_extract(data$title_japanese),
      safe_extract(data$type),
      safe_extract(data$source),
      safe_extract(data$episodes),
      safe_extract(data$status),
      safe_extract(data$airing),
      safe_extract(data$aired$from),
      safe_extract(data$aired$to),
      safe_extract(data$duration),
      safe_extract(data$rating),
      safe_extract(data$score),
      safe_extract(data$scored_by),
      safe_extract(data$rank),
      safe_extract(data$popularity),
      safe_extract(data$members),
      safe_extract(data$favorites),
      safe_extract(data$synopsis),
      safe_extract(data$background),
      safe_extract(data$season),
      safe_extract(data$year),
      safe_extract(data$broadcast$day),
      safe_extract(data$broadcast$time),
      safe_extract(data$broadcast$timezone),
      safe_extract(data$url)
    ))
    
  } else {
    cat("Failed fetching ID:", anime_id, "Status:", status_code(resp), "\n")
  }
}


# Example: Fetch anime with ID from 1 to 5
for (id in 1:5) {
  fetch_and_insert_anime(id)
  Sys.sleep(0.5)  # Avoid hitting the API rate limit (3 requests per second)
}


```

```{r}
dbGetQuery(conn, "SELECT * FROM anime_full")


```

```{r}
# Disconnect database when done
dbDisconnect(conn)
```

```{r}
library(httr)
library(jsonlite)
library(DBI)
library(RSQLite)

# Connect to database
conn <- dbConnect(SQLite(), "anime_full_database.sqlite")

safe_extract <- function(x) {
  if (is.null(x) || length(x) == 0) {
    return(NA)
  } else {
    return(x)
  }
}

insert_anime <- function(data) {
  dbExecute(conn, "
    INSERT OR REPLACE INTO anime_full 
    (mal_id, title, title_english, title_japanese, type, source, episodes, status, airing, aired_from, aired_to, duration, rating, score, scored_by, rank, popularity, members, favorites, synopsis, background, season, year, broadcast_day, broadcast_time, broadcast_timezone, url)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  ", params = list(
    safe_extract(data[["mal_id"]]),
    safe_extract(data[["title"]]),
    safe_extract(data[["title_english"]]),
    safe_extract(data[["title_japanese"]]),
    safe_extract(data[["type"]]),
    safe_extract(data[["source"]]),
    safe_extract(data[["episodes"]]),
    safe_extract(data[["status"]]),
    safe_extract(data[["airing"]]),
    safe_extract(data[["aired"]][["from"]]),
    safe_extract(data[["aired"]][["to"]]),
    safe_extract(data[["duration"]]),
    safe_extract(data[["rating"]]),
    safe_extract(data[["score"]]),
    safe_extract(data[["scored_by"]]),
    safe_extract(data[["rank"]]),
    safe_extract(data[["popularity"]]),
    safe_extract(data[["members"]]),
    safe_extract(data[["favorites"]]),
    safe_extract(data[["synopsis"]]),
    safe_extract(data[["background"]]),
    safe_extract(data[["season"]]),
    safe_extract(data[["year"]]),
    safe_extract(data[["broadcast"]][["day"]]),
    safe_extract(data[["broadcast"]][["time"]]),
    safe_extract(data[["broadcast"]][["timezone"]]),
    safe_extract(data[["url"]])
  ))
}


fetch_page_anime <- function(page_num) {
  url <- paste0("https://api.jikan.moe/v4/anime?page=", page_num)
  resp <- GET(url)
  
  if (status_code(resp) == 200) {
    result <- fromJSON(content(resp, "text", encoding = "UTF-8"), simplifyVector = FALSE)
    anime_list <- result$data
    
    for (i in seq_along(anime_list)) {
      insert_anime(anime_list[[i]])
    }
    
    cat("Page", page_num, "done! Inserted", length(anime_list), "animes.\n")
  } else {
    cat("Failed to fetch page", page_num, "Status:", status_code(resp), "\n")
  }
}


# Example: Fetch pages 1 to 3
for (page in 1:1000) {
  fetch_page_anime(page)
  Sys.sleep(1) # avoid being rate-limited
}

for (page in 1000:1100) {
  fetch_page_anime(page)
  Sys.sleep(1) # avoid being rate-limited
}

for (page in 1100:1150) {
  fetch_page_anime(page)
  Sys.sleep(1) # avoid being rate-limited
}



```

```{r}
dbExecute(conn, "ALTER TABLE anime_full ADD COLUMN genres TEXT;")

```

```{r}
library(httr)
library(jsonlite)

fetch_anime_genres <- function(mal_id) {
  url <- paste0("https://api.jikan.moe/v4/anime/", mal_id)
  resp <- GET(url)
  
  if (status_code(resp) == 200) {
    data <- fromJSON(content(resp, "text", encoding = "UTF-8"))$data
    genres_list <- data$genres
    if (length(genres_list) == 0) {
      return(NA)
    } else {
      return(paste(genres_list$name, collapse = ", "))
    }
  } else {
    return(NA)
  }
}
mal_ids <- dbGetQuery(conn, "SELECT mal_id FROM anime_full")$mal_id
summary(mal_ids)
length(mal_ids)
```

```{r}
for (i in seq_along(mal_ids)) {
  id <- mal_ids[i]
  genres <- fetch_anime_genres(id)
  
  # Update the database
  dbExecute(conn, "UPDATE anime_full SET genres = ? WHERE mal_id = ?", params = list(genres, id))
  
  cat("Updated mal_id:", id, "Genres:", genres, "\n")
  
  Sys.sleep(0.5) # Sleep to avoid hitting API rate limit
}

# Find the index where mal_id == 17563
start_index <- which(mal_ids == 34283)

# Loop from start_index to the end
for (i in start_index:length(mal_ids)) {
  id <- mal_ids[i]
  genres <- fetch_anime_genres(id)
  
  # Update the database
  dbExecute(conn, "UPDATE anime_full SET genres = ? WHERE mal_id = ?", params = list(genres, id))
  
  cat("Updated mal_id:", id, "Genres:", genres, "\n")
  
  Sys.sleep(0.5) # Sleep to avoid API rate limit
}



```

```{r}

dbGetQuery(conn, "SELECT * FROM anime_full")
dbGetQuery(conn, "SELECT COUNT(*) FROM anime_full")
dbGetQuery(conn, "SELECT * FROM anime_full ORDER BY mal_id DESC LIMIT 25")
```

```{r}
# Disconnect after everything done
dbDisconnect(conn)
```

## Check NAs

```{r}

library(DBI)
library(RSQLite)

# Connect if not already
conn <- dbConnect(SQLite(), "anime_full_database.sqlite")

# Read the table
anime_data <- dbReadTable(conn, "anime_full")

# Total number of rows
n_rows <- nrow(anime_data)

# Find missing percentage for each column
missing_summary <- sapply(anime_data, function(x) sum(is.na(x)) / n_rows * 100)

# Turn into a nice data frame
missing_df <- data.frame(
  column = names(missing_summary),
  missing_percent = round(missing_summary, 2)  # Round to 2 decimal places
)

# Sort by missing_percent descending
missing_df <- missing_df[order(-missing_df$missing_percent), ]

print(missing_df)


```

```{r}
# NA graph
library(ggplot2)

ggplot(missing_df, aes(x = reorder(column, -missing_percent), y = missing_percent)) +
  geom_bar(stat = "identity") +
  coord_flip() +
  labs(x = "Column", y = "Missing Data (%)", title = "Percent Missing in anime_full Table")


```

When title is missing, the entire row is invalid, we remove rows with title missing

```{r}
# Read the anime_full table
anime_data <- dbReadTable(conn, "anime_full")
# Keep only rows where title is NOT missing
anime_data <- anime_data[!is.na(anime_data$title), ]
sum(is.na(anime_data$title))
nrow(anime_data)

```

The valid anime rows is now 28318 instead of 28477. Inspect missing values again:

```{r}
# Total number of rows
n_rows <- nrow(anime_data)

# Find missing percentage for each column
missing_summary <- sapply(anime_data, function(x) sum(is.na(x)) / n_rows * 100)

# Turn into a nice data frame
missing_df <- data.frame(
  column = names(missing_summary),
  missing_percent = round(missing_summary, 2)  # Round to 2 decimal places
)

# Sort by missing_percent descending
missing_df <- missing_df[order(-missing_df$missing_percent), ]

print(missing_df)

# Missing value graph for the report
ggplot(missing_df, aes(x = reorder(column, missing_percent), y = missing_percent, fill = -missing_percent)) +
    geom_bar(stat = "identity") +
    geom_text(aes(label = paste0(round(missing_percent, 1), "%")), 
              hjust = -0.1,  # Move the label a little to the right of bar
              size = 4) +    # Text size
    coord_flip() +
    labs(x = "Attribute", y = "Missing Data (%)", title = "Percent Missing of each Attribute in Jikan Anime Data", fill = "Missing Percent" ) +
    theme_minimal() +
    theme(plot.title = element_text(hjust = 0.5, size = 28, face = "bold"),
          axis.title.x = element_text(size = 19),
          axis.title.y = element_text(size = 19),
          axis.text.y = element_text(size = 14),)


```

Last, we remove rows that don't have genre appear

```{r}
conn <- dbConnect(SQLite(), "anime_full_database.sqlite")

# Read the anime_full table
anime_data <- dbReadTable(conn, "anime_full")
# Keep only rows where title is NOT missing
anime_data <- anime_data[!is.na(anime_data$title), ]
nrow(anime_data)
# Keep only rows where genres is NOT missing
anime_data <- anime_data[!is.na(anime_data$genres),]
nrow(anime_data)

```
